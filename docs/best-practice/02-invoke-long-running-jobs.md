# 编排长任务

我们把执行时间超过10s的任务定义为“长任务”，执行长任务时无法立刻获取任务结果，需要等待任务结束后再执行下一个节点。

Rill Flow设计上对流程上下文做了持久化存储，因此长任务执行的过程中即使对Rill Flow本身做了重启或升级，也不会丢失流程执行的上下文。

我们把常见的长任务分成四类，Rill Flow可以通过不同的方式与这些类型的长任务进行对接。

> 在实践中，建议执行时间超过1个月的任务不建议使用Rill Flow编排（当然，是可以编排的）。

## 对接调用-等待型长任务
发起任务后需要同步等待接口返回，根据对应服务部署的模式不同，可以有两种对接方式：

### 调用云服务：派发器建立异步线程池
当对应的执行服务部署在公网上时，可以通过在派发器中增加异步执行线程池，避免派发线程长时间被长任务请求夯死，详情请参考代码中的`ChatGPT`插件对应实现。

> 当Rill Flow服务自身重启时，对应的请求也会丢失，需要在派发器中增加优雅关闭相关逻辑

### 调用自有服务：增加执行器Agent
当对应的执行器是自有服务时，建议通过Sidecar方式为服务增加调用Agent，由Agent维持与实际服务的请求，当请求结束时由Agent回调Rill Flow通知任务执行结果。

![executor agent](assets/executor-agent.svg)

通过增加Agent，可以有效的避免由于网络或其他问题导致的长连接请求失败问题。
 
## 对接调用-轮询型长任务
发起任务后获得token，后续通过任务查询接口获取进度。

* 在流程中增加“调用”和“查询”两个节点
* 通过参数映射机制，在任务间传递任务的token

## 对接调用-回调型长任务
发起任务时指定callback，任务完成后回调指定接口。

在任务中直接回调Rill Flow完成接口，或者业务实现回调转发逻辑，将原任务的回调请求转换封装后调用到Rill Flow。

## 对接流式长任务
发起任务后可以持续向某种流内持续写入数据。

当前Rill Flow暂时不支持原生的流式任务编排，需要将流式处理逻辑自行封装到Executor中。