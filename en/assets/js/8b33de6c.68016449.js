"use strict";(self.webpackChunkrill_flow_github_io=self.webpackChunkrill_flow_github_io||[]).push([[7981],{2320:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>h,frontMatter:()=>o,metadata:()=>r,toc:()=>c});var i=s(5893),t=s(1151);const o={sidebar_position:1},l="Intro",r={id:"intro",title:"Intro",description:"What is Rill Flow?",source:"@site/i18n/en/docusaurus-plugin-content-docs/current/01-intro.md",sourceDirName:".",slug:"/intro",permalink:"/en/docs/intro",draft:!1,unlisted:!1,editUrl:"https://crowdin.com/project/rill-flow/en",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",next:{title:"\u5feb\u901f\u5f00\u59cb",permalink:"/en/docs/category/\u5feb\u901f\u5f00\u59cb"}},a={},c=[{value:"What is Rill Flow?",id:"what-is-rill-flow",level:2},{value:"Why Rill Flow?",id:"why-rill-flow",level:2},{value:"Organize asynchronous tasks",id:"organize-asynchronous-tasks",level:3},{value:"Parallel processing",id:"parallel-processing",level:3},{value:"LLMs",id:"llms",level:3},{value:"Serve with Serverless",id:"serve-with-serverless",level:3},{value:"Major Advantage of Rill Flow",id:"major-advantage-of-rill-flow",level:3},{value:"Why not Rill Flow?",id:"why-not-rill-flow",level:2},{value:"Orchestrate single-machine low-latency synchronization tasks",id:"orchestrate-single-machine-low-latency-synchronization-tasks",level:3},{value:"Next",id:"next",level:2}];function d(e){const n={a:"a",h1:"h1",h2:"h2",h3:"h3",img:"img",li:"li",p:"p",ul:"ul",...(0,t.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"intro",children:"Intro"}),"\n",(0,i.jsx)(n.h2,{id:"what-is-rill-flow",children:"What is Rill Flow?"}),"\n",(0,i.jsx)(n.p,{children:"Rill Flow is a high-performance and scalable distribution process programming service that was initially designed to address the complexity of the processes under the microblog video business scenario and the performance problems associated with the implementation of large traffic tasks, so that ease of usage, high and low latency is a core feature of Rill Flow."}),"\n",(0,i.jsx)(n.p,{children:"At present, Rill Flow has been widely used in Weibo, with a daily processing volume of tens of millions, supporting the core processes of Weibo's multiple businesses such as business orchestration, media processing, and AIGC."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"Architecture",src:s(6655).Z+"",width:"901",height:"301"})}),"\n",(0,i.jsx)(n.h2,{id:"why-rill-flow",children:"Why Rill Flow?"}),"\n",(0,i.jsx)(n.p,{children:"Rill Flow is designed to solve the orchestration of complex business processes and the execution performance of large-traffic tasks. It is also optimized and adapted for cloud-native architecture and large-scale language model (LLM) applications. It is a solution for complex processes in cloud-native distributed scenarios. An excellent solution for orchestration, large-traffic task execution performance, and rapid integration of AIGC applications."}),"\n",(0,i.jsx)(n.h3,{id:"organize-asynchronous-tasks",children:"Organize asynchronous tasks"}),"\n",(0,i.jsx)(n.p,{children:"For some asynchronous processes that take a long time to execute, such as OA approval workflow, graphical arrangement and execution can effectively improve development efficiency and reduce subsequent maintenance costs.Rill Flow supports asynchronization and visualization of asynchronous processes, which can be effectively interfaced."}),"\n",(0,i.jsx)(n.h3,{id:"parallel-processing",children:"Parallel processing"}),"\n",(0,i.jsx)(n.p,{children:"When running heavy-duty tasks such as media processing, you may need to shard the task and use multiple servers to work together to reduce task processing latency.Rill Flow provides good support for parallel distribution and can quickly implement task segmentation, parallel processing and merging processes."}),"\n",(0,i.jsx)(n.h3,{id:"llms",children:"LLMs"}),"\n",(0,i.jsx)(n.p,{children:"The development of LLM technology has brought about the rapid development of models. Large models that handle different tasks may contain different runtime dependencies or resource requirements, and different languages and technology stacks may need to be used in the entire process link.Use Rill Flow to better organize and coordinate different large models and related tasks, distribute different tasks to different proprietary models, decouple models and couples, and promote model localization."}),"\n",(0,i.jsx)(n.h3,{id:"serve-with-serverless",children:"Serve with Serverless"}),"\n",(0,i.jsx)(n.p,{children:"Serveress technology can effectively reduce transaction costs and can be deployed on demand by encapsulating logic to an independent `function'.At the same time, due to the atomicity of Serverless, when the business process needs to connect different Serverless, some 'glue code' is needed. Rill Flow can well connect with Serverless functions and realize business requirements quickly and at low cost."}),"\n",(0,i.jsx)(n.h3,{id:"major-advantage-of-rill-flow",children:"Major Advantage of Rill Flow"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"High performance: Supports the execution of tens of millions of tasks per day, with execution latency less than 100ms"}),"\n",(0,i.jsx)(n.li,{children:"Distributed: Supports orchestration and scheduling of heterogeneous distributed systems"}),"\n",(0,i.jsx)(n.li,{children:"Ease of use: supports visual process orchestration and plugins"}),"\n",(0,i.jsx)(n.li,{children:"Cloud Native: Supports cloud native container deployment and cloud native function orchestration"}),"\n",(0,i.jsx)(n.li,{children:"AIGC: Supports rapid integration of LLMs"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"why-not-rill-flow",children:"Why not Rill Flow?"}),"\n",(0,i.jsx)(n.h3,{id:"orchestrate-single-machine-low-latency-synchronization-tasks",children:"Orchestrate single-machine low-latency synchronization tasks"}),"\n",(0,i.jsx)(n.p,{children:"Rill Flow is designed as a distributed orchestration framework, which will introduce additional performance losses in a single-machine scenario.If the execution time of a complete process is less than 1 second, the overall benefit of introducing Rill Flow may be reduced."}),"\n",(0,i.jsx)(n.h2,{id:"next",children:"Next"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/en/docs/getting-started/quickstart",children:"Quick Start"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/en/docs/getting-started/sample",children:"More samples"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/en/docs/user-guide/arch",children:"Architecture"})}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,t.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},6655:(e,n,s)=>{s.d(n,{Z:()=>i});const i=s.p+"assets/images/flow_arch-abc957a5102626a91192ecb7b3560f5e.svg"},1151:(e,n,s)=>{s.d(n,{Z:()=>r,a:()=>l});var i=s(7294);const t={},o=i.createContext(t);function l(e){const n=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:l(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);